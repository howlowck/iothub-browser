{"version":3,"file":"index.js","sources":["../src/utils.js","../src/monitorEvents.js","../src/connectDevice.js"],"sourcesContent":["import createHmac from 'create-hmac'\r\n\r\nexport const getTimestampExpiresInMinutes = (minutes) => {\r\n  return Math.ceil((Date.now() / 1000) + minutes * 60)\r\n}\r\n\r\nexport const getSignatureString = (sigObj) => {\r\n  var header = 'SharedAccessSignature '\r\n  var qstr = ['sr', 'sig', 'se', 'skn']\r\n    .map((key) => {\r\n      if (!sigObj[key]) {\r\n        return null\r\n      }\r\n      return key + '=' + sigObj[key]\r\n    }, '')\r\n    .filter(_ => _)\r\n    .join('&')\r\n  return header + qstr\r\n}\r\n\r\nexport const createBase64SasToken = (encodedResourceUri, signingKey, expireTimestamp) => {\r\n  // Set expiration in seconds\r\n  const toSign = encodedResourceUri + '\\n' + expireTimestamp\r\n  const hmac = createHmac('sha256', new Buffer(signingKey, 'base64'))\r\n  hmac.update(toSign)\r\n  const digest = hmac.digest('base64')\r\n  return encodeURIComponent(digest)\r\n}\r\n\r\nexport const createSignatureObj = (hostName, policyName, sas, expireTimestamp) => {\r\n  const encodedHostName = encodeURIComponent(hostName)\r\n  const result = {\r\n    _key: sas,\r\n    sr: encodedHostName,\r\n    se: expireTimestamp,\r\n    sig: createBase64SasToken(encodedHostName, sas, expireTimestamp)\r\n  }\r\n  if (policyName) {\r\n    result.skn = policyName\r\n  }\r\n  return result\r\n}\r\n\r\nexport const parseConnectionString = (connStr) => {\r\n  return connStr\r\n    .split(';')\r\n    .reduce((prev, curr, index) => {\r\n      const searchInd = curr.search('=')\r\n      const key = curr.slice(0, searchInd)\r\n      const value = curr.slice(searchInd + 1)\r\n      prev[key] = value\r\n      return prev\r\n    }, {})\r\n}\r\n\r\nexport const getHostNameFromEndpoint = (endpoint) => {\r\n  return endpoint.slice(5, -1)\r\n}\r\n","/* global WebSocket */\r\nimport amqp from 'rhea'\r\nimport {parseConnectionString, getHostNameFromEndpoint} from './utils'\r\nimport debug from 'debug'\r\nconst log = debug('monitor-events')\r\n\r\nexport default function monitorEvents (eventHubName, eventHubConnectionString, onMessage) {\r\n  // 0. set up the config\r\n  const connectionObj = parseConnectionString(eventHubConnectionString)\r\n  const hostName = getHostNameFromEndpoint(connectionObj.Endpoint)\r\n  const policyName = connectionObj.SharedAccessKeyName\r\n  const sas = connectionObj.SharedAccessKey\r\n\r\n  const url = `wss://${hostName}:443/$servicebus/websocket?iothub-no-client-cert=true`\r\n  const ws = amqp.websocket_connect(WebSocket)\r\n\r\n  // 1. connect to eventhub\r\n  const connection = amqp.connect({\r\n    hostname: hostName,\r\n    container_id: 'conn' + Date.now(),\r\n    max_frame_size: 4294967295,\r\n    channel_max: 65535,\r\n    idle_timeout: 120000,\r\n    outgoing_locales: 'en-US',\r\n    incoming_locales: 'en-US',\r\n    offered_capabilities: null,\r\n    desired_capabilities: null,\r\n    properties: {},\r\n    connection_details: ws(url, ['AMQPWSB10']),\r\n    reconnect: false,\r\n    username: policyName,\r\n    password: sas\r\n  })\r\n\r\n  let sender\r\n\r\n  // 2. open communication for $management to get partitionIds\r\n  amqp.on('connection_open', function (context) {\r\n    connection.open_receiver('$management')\r\n    sender = connection.open_sender('$management')\r\n  })\r\n\r\n  // 3. send the request to get the partitionIds\r\n  amqp.once('sendable', function (context) {\r\n    sender.send({\r\n      body: '[]',\r\n      application_properties: {\r\n        operation: 'READ',\r\n        name: eventHubName, // hostName,\r\n        type: 'com.microsoft:eventhub'\r\n      }\r\n    })\r\n  })\r\n\r\n  // 4. set up filter to only capture from the current timestamp (otherwise will get all events)\r\n  const currentTimestamp = Date.now()\r\n  const filterClause = `amqp.annotation.x-opt-enqueuedtimeutc > '${currentTimestamp}'`\r\n\r\n  const opts = (partId) => ({\r\n    desired_capabilities: 'com.microsoft:enable-receiver-runtime-metric',\r\n    autoaccept: true,\r\n    source: {\r\n      address: 'hao-gl-iothub/ConsumerGroups/$default/Partitions/' + partId,\r\n      filter: {\r\n        'apache.org:selector-filter:string': amqp.types.wrap_described(filterClause, 0x468C00000004)\r\n      }\r\n    }\r\n  })\r\n\r\n  // 5. Open communication to all partitionId paths, register user-defined onMessage callback\r\n  amqp.once('message', function (context) {\r\n    log('monitoring from eventhub endpoint on iothub ...')\r\n    const partitionIds = context.message.body.partition_ids\r\n    partitionIds.forEach(partId => {\r\n      connection.attach_receiver(opts(partId))\r\n    })\r\n    amqp.on('message', (context) => {\r\n      log(context)\r\n      onMessage(context.message.body.content.toString(), context)\r\n    })\r\n  })\r\n\r\n  const close = connection.close.bind(connection)\r\n\r\n  return {\r\n    close\r\n  }\r\n}\r\n","import {connect} from 'mqtt'\r\nimport {getTimestampExpiresInMinutes, parseConnectionString, createSignatureObj, getSignatureString} from './utils'\r\nimport debug from 'debug'\r\nconst log = debug('device')\r\n\r\nexport default function connectDevice (deviceConnectionString, onC2DMessage) {\r\n  // 0. Set up Config\r\n  const expireTimestamp = getTimestampExpiresInMinutes(60)\r\n  const connObj = parseConnectionString(deviceConnectionString)\r\n  const hostName = connObj.HostName\r\n  const sas = connObj.SharedAccessKey\r\n  const deviceId = connObj.DeviceId\r\n  const sigObj = createSignatureObj(`${hostName}/devices/${deviceId}`, null, sas, expireTimestamp)\r\n  const sigStr = getSignatureString(sigObj)\r\n\r\n  const config = {\r\n    clean: false,\r\n    clientId: deviceId,\r\n    keepalive: 180,\r\n    password: sigStr,\r\n    protocolId: 'MQTT',\r\n    protocolVersion: 4,\r\n    reconnectPeriod: 1000,\r\n    rejectUnauthorized: true,\r\n    connectTimeout: 30 * 1000,\r\n    reschedulePings: true,\r\n    username: `${hostName}/${deviceId}/api-version=2017-06-30`\r\n  }\r\n\r\n  // 1. Connect to IotHub via websocket\r\n  const client = connect(`wss://${hostName}:443/$iothub/websocket?iothub-no-client-cert=true`, config)\r\n\r\n  // 2. Register event listeners\r\n  client.on('connect', function () {\r\n    log('emitter connected!')\r\n  })\r\n\r\n  client.on('offline', function () {\r\n    log('emitter offline')\r\n  })\r\n\r\n  client.on('close', function () {\r\n    log('emitter closed!')\r\n  })\r\n\r\n  client.on('message', onC2DMessage)\r\n\r\n  client.on('packetsend', () => {\r\n    log('trying to send pocket..')\r\n  })\r\n\r\n  // 3. Subscribe to topic for C2D messages\r\n  client.subscribe(`devices/${deviceId}/messages/devicebound/#`, { qos: 0 })\r\n\r\n  // 4. Return publish function\r\n  const publish = (messageStr, params = {}) => {\r\n    const appProps = Object.keys(params).map((key) => {\r\n      return encodeURIComponent(key) + '=' + encodeURIComponent(params[key])\r\n    }).join('&')\r\n    client.publish(`devices/${deviceId}/messages/events/${appProps}`, messageStr, { qos: 1, retain: false })\r\n  }\r\n\r\n  const close = client.end.bind(client)\r\n\r\n  return {\r\n    publish,\r\n    close\r\n  }\r\n}\r\n"],"names":["getTimestampExpiresInMinutes","minutes","Math","ceil","Date","now","getSignatureString","sigObj","map","key","filter","_","join","createSignatureObj","hostName","policyName","sas","expireTimestamp","const","encodedHostName","encodeURIComponent","result","_key","sr","se","sig","encodedResourceUri","signingKey","toSign","hmac","createHmac","Buffer","update","digest","createBase64SasToken","skn","parseConnectionString","connStr","split","reduce","prev","curr","index","searchInd","search","slice","value","getHostNameFromEndpoint","endpoint","log","debug","eventHubName","eventHubConnectionString","onMessage","sender","connectionObj","Endpoint","SharedAccessKeyName","SharedAccessKey","url","ws","amqp","websocket_connect","WebSocket","connection","connect","hostname","container_id","max_frame_size","channel_max","idle_timeout","outgoing_locales","incoming_locales","offered_capabilities","desired_capabilities","properties","connection_details","reconnect","username","password","on","context","open_receiver","open_sender","once","send","body","application_properties","operation","name","type","filterClause","message","partition_ids","forEach","partId","attach_receiver","autoaccept","source","address","apache.org:selector-filter:string","types","wrap_described","opts","content","toString","close","bind","deviceConnectionString","onC2DMessage","connObj","HostName","deviceId","DeviceId","sigStr","client","clean","clientId","keepalive","protocolId","protocolVersion","reconnectPeriod","rejectUnauthorized","connectTimeout","reschedulePings","subscribe","qos","messageStr","params","appProps","Object","keys","publish","retain","end"],"mappings":"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"}